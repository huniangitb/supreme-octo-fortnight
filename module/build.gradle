import org.apache.tools.ant.filters.FixCrLfFilter

import java.nio.file.Paths
import java.nio.file.Files

apply plugin: 'com.android.library'
apply from: file(rootProject.file('module.gradle'))

android {
    compileSdkVersion rootProject.ext.targetSdkVersion
    defaultConfig {
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        externalNativeBuild {
            cmake {
                arguments "-DMODULE_NAME:STRING=$moduleLibraryName", "-DCMAKE_EXPORT_COMPILE_COMMANDS:STRING=ON"
            }
        }
    }
    buildFeatures {
        prefab true
    }
    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.22.1"
        }
    }
    namespace 'aknoryx.zygisktz'
}

repositories {
    mavenLocal()
}

// 引入 AGP 8.x 的 Artifact API 类
import com.android.build.api.artifact.Artifact
import com.android.build.api.variant.LibraryPackaging

afterEvaluate {
    android.libraryVariants.forEach { variant ->
        def variantCapped = variant.name.capitalize()
        def variantLowered = variant.name.toLowerCase()

        def zipName = "${magiskModuleId.replace('_', '-')}-${moduleVersion}-${variantLowered}.zip"
        def magiskDir = file("$outDir/magisk_module_$variantLowered")

        task("prepareMagiskFiles${variantCapped}", type: Sync) {
            dependsOn("assemble$variantCapped")

            def templatePath = "$rootDir/template/magisk_module"

            into magiskDir
            from(templatePath) {
                exclude 'module.prop'
            }
            from(templatePath) {
                include 'module.prop'
                expand([
                        id         : magiskModuleId,
                        name       : moduleName,
                        version    : moduleVersion,
                        versionCode: moduleVersionCode.toString(),
                        author     : moduleAuthor,
                        description: moduleDescription,
                ])
                filter(FixCrLfFilter.class,
                        eol: FixCrLfFilter.CrLf.newInstance("lf"))
            }

            // ***************************************************************
            // *** 核心修改部分：使用 AGP 8.x Artifact API 获取 JNI 库路径 ***
            // ***************************************************************
            
            // 获取所有 JNI 库的目录，AGP 8.x 推荐使用 LibraryPackaging.JNI_LIBS_JNI_DIRECTORIES
            // 这会返回一个 Provider，指向包含所有 ABI 目录的父目录
            def jniLibsDirs = variant.artifacts.get(LibraryPackaging.JNI_LIBS_JNI_DIRECTORIES)
            
            from(jniLibsDirs) {
                // 如果 jniLibsDirs 是 Provider<Directory>，它应该包含 /arm64-v8a, /armeabi-v7a 等子目录
                // 我们将这些子目录复制到 'lib' 目录下
                into 'lib'
            }

            // ***************************************************************
            // *** 修正后的 doLast 块 ***
            // ***************************************************************
            doLast {
                file("$magiskDir/zygisk").mkdir()
                
                // 遍历 lib 目录下的所有 ABI 目录
                fileTree("$magiskDir/lib").visit { f ->
                    if (!f.directory) return // 跳过文件
                    
                    // 假设 f.file 是 /magisk_module_release/lib/arm64-v8a
                    
                    // 构建源路径：/lib/arm64-v8a/lib{moduleLibraryName}.so
                    def srcPath = Paths.get("${f.file.absolutePath}/lib${moduleLibraryName}.so")
                    
                    // 获取 ABI 名称 (例如 arm64-v8a)
                    def abiName = f.name 
                    
                    // 构建目标路径：/zygisk/{abiName}.so
                    def dstPath = Paths.get("$magiskDir/zygisk/${abiName}.so")
                    
                    if (Files.exists(srcPath)) {
                        Files.move(srcPath, dstPath)
                    } else {
                        // 打印警告或错误，如果找不到 .so 文件，可能是 CMake 配置问题
                        println("Warning: Native library not found at ${srcPath}")
                    }
                }
                new File("$magiskDir/lib").deleteDir()
            }
        }

        task("zip${variantCapped}", type: Zip) {
            dependsOn("prepareMagiskFiles${variantCapped}")
            from magiskDir
            archiveFileName.set(zipName)
            destinationDirectory.set(outDir)
        }

        task("push${variantCapped}", type: Exec) {
            dependsOn("zip${variantCapped}")
            workingDir outDir
            commandLine android.adbExecutable, "push", zipName, "/data/local/tmp/"
        }

        task("flash${variantCapped}", type: Exec) {
            dependsOn("push${variantCapped}")
            commandLine android.adbExecutable, "shell", "su", "-c",
                    "magisk --install-module /data/local/tmp/${zipName}"
        }

        task("flashAndReboot${variantCapped}", type: Exec) {
            dependsOn("flash${variantCapped}")
            commandLine android.adbExecutable, "shell", "reboot"
        }

        variant.assembleProvider.get().finalizedBy("zip${variantCapped}")
    }
}